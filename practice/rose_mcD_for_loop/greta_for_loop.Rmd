---
title: "greta_for_loop"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

------------------------------------------------------------------------

title: "Ross–Macdonald in Plain R vs greta.dynamics" author: "Ernest
Moyo" date: "`r format(Sys.Date(), '%d %B %Y')`" output: html_document:
toc: true toc_depth: 3 number_sections: true df_print: paged
pdf_document: toc: true ---------

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 4)
```

# Overview

This R Markdown documents two ways to simulate the Ross–Macdonald
malaria model:

1.  Plain R forward‑Euler (deterministic, minimal dependencies).
2.  greta + greta.dynamics (same dynamics inside a probabilistic graph;
    can be extended to Bayesian inference).

We also note what greta adds (priors, likelihoods, MCMC) and include a
minimal Bayesian template.

# Model definition

Human infection proportion x(t) and mosquito infection proportion z(t):

-   dx/dt = m \* a \* b \* z \* (1 - x) - r \* x
-   dz/dt = a \* c \* x \* (1 - z) - g \* z

States: x(t), z(t) in [0,1]. Parameters (daily units): m, a, b, c, r =
1/infection_duration, g = 1/mosquito_lifespan.

Baseline numbers:

```{r params}
m <- 100; a <- 0.1; b <- 0.9; c <- 0.9
infection_duration <- 21; r <- 1/infection_duration
mosquito_lifespan  <- 21; g <- 1/mosquito_lifespan
x_init <- 0.02; z_init <- 0.001
```

Right‑hand sides (R functions):

```{r rhs}
dx_dt <- function(x, z, m, a, b, r) m * a * b * z * (1 - x) - r * x

dz_dt <- function(x, z, a, c, g)   a * c * x * (1 - z) - g * z
```

Instantaneous rates at the initial state (x0, z0):

```{r initial-slopes}
dx0 <- dx_dt(x_init, z_init, m, a, b, r)
dz0 <- dz_dt(x_init, z_init, a, c, g)
cat(sprintf("dx/dt at t0: %.6f per day
", dx0))
cat(sprintf("dz/dt at t0: %.6f per day
", dz0))
```

# Way 1 — Plain R Euler simulation

A forward‑Euler step with step size DT updates:

-   x[i+1] = x[i] + dx_dt(x[i], z[i], ...)\*DT
-   z[i+1] = z[i] + dz_dt(x[i], z[i], ...)\*DT

```{r plain-euler}
t_max <- 10
DT    <- 0.1
t     <- seq(0, t_max, by = DT)
n_t   <- length(t)

x <- z <- rep(NA_real_, n_t)
x[1] <- x_init; z[1] <- z_init

for (i in 2:n_t) {
  x[i] <- x[i - 1] + dx_dt(x[i - 1], z[i - 1], m, a, b, r) * DT
  z[i] <- z[i - 1] + dz_dt(x[i - 1], z[i - 1], a, c, g)   * DT
  # optional safety clamp if experimenting with large steps
  x[i] <- pmin(pmax(x[i], 0), 1)
  z[i] <- pmin(pmax(z[i], 0), 1)
}
```

```{r plot-plain, fig.height=4}
par(mfrow = c(1, 2))
plot(t, x, type = "l", xlab = "time (days)", ylab = "x (humans infected)", main = "Plain R: x(t)")
plot(t, z, type = "l", xlab = "time (days)", ylab = "z (mosq. infected)", main = "Plain R: z(t)")
par(mfrow = c(1, 1))
```

Notes:

-   Deterministic only; no uncertainty quantification.
-   Accuracy depends on DT. Use smaller steps if dynamics are fast.

# Way 2 — greta + greta.dynamics (deterministic run)

We build the same Euler simulation inside a greta computational graph.
Later, attach priors/likelihoods and run MCMC for Bayesian inference.

```{r greta-setup, message=TRUE}
# Install if needed (uncomment):
# install.packages("greta")
# remotes::install_github("greta-dev/greta.dynamics")

library(greta)
library(greta.dynamics)
```

Convert constants to greta data (greta arrays):

```{r greta-data}
m_g  <- as_data(m)
a_g  <- as_data(a)
b_g  <- as_data(b)
r_g  <- as_data(r)
c_g  <- as_data(c)
g_g  <- as_data(g)
DT_g <- as_data(0.1)

x0_g <- as_data(x_init)
z0_g <- as_data(z_init)

t_seq  <- seq(0, t_max, by = as.numeric(DT_g))
n_step <- length(t_seq) - 1
```

Define a greta‑compatible Euler transition:

```{r greta-transition}
step_greta <- function(state, m, a, b, c, r, g, DT, iter) {
  x <- state[1]; z <- state[2]
  x_next <- x + dx_dt(x, z, m, a, b, r) * DT
  z_next <- z + dz_dt(x, z, a, c, g)   * DT
  c(x_next, z_next)
}
```

Build the trajectory in the greta graph and evaluate to numerics:

```{r greta-run}
sol <- iterate_dynamic_function(
  transition_function = step_greta,
  initial_state = c(x0_g, z0_g),
  niter = n_step,
  tol = 0,          # purely deterministic
  m = m_g, a = a_g, b = b_g, c = c_g, r = r_g, g = g_g, DT = DT_g
)

x_ts_g <- sol$all_states[1, ]
z_ts_g <- sol$all_states[2, ]

vals <- calculate(x = x_ts_g, z = z_ts_g)
x_g_num <- as.numeric(vals$x)
z_g_num <- as.numeric(vals$z)
# time indices in greta output correspond to t_seq[-1] (after first step)
```

```{r plot-greta, fig.height=4}
par(mfrow = c(1, 2))
plot(t_seq[-1], x_g_num, type = "l", xlab = "time (days)", ylab = "x", main = "greta.dynamics: x(t)")
plot(t_seq[-1], z_g_num, type = "l", xlab = "time (days)", ylab = "z", main = "greta.dynamics: z(t)")
par(mfrow = c(1, 1))
```

What greta buys you:

-   Dynamics and parameters live in a probabilistic graph.
-   Add priors on parameters and a likelihood linking states to data;
    sample the posterior via mcmc().
-   Uncertainty‑aware estimates and predictions.

# Minimal Bayesian extension (template)

This is a sketch for when you have data; it won’t run until you define
observations y, sample sizes n, and the index mapping idx.

```{r bayes-template, eval=FALSE}
# Example priors (tune to your context)
m_g  <- lognormal(log(100), 0.3)
a_g  <- beta(2, 18)     # mean approx 0.1 on [0,1]
b_g  <- beta(9, 1)      # mean approx 0.9
c_g  <- beta(9, 1)
r_g  <- as_data(1/21)
g_g  <- as_data(1/21)
DT_g <- as_data(0.1)

# Build trajectory as before
sol <- iterate_dynamic_function(step_greta, c(x0_g, z0_g), n_step, tol = 0,
  m = m_g, a = a_g, b = b_g, c = c_g, r = r_g, g = g_g, DT = DT_g)

x_ts <- sol$all_states[1, ]  # greta array

# Suppose at selected times idx you observe y positives out of n tested
for (i in 1:n_obs) {
  y[i] ~ binomial(size = n[i], prob = x_ts[idx[i]])
}

# Build and sample the model
m <- model(y)
draws <- mcmc(m, n_samples = 2000, warmup = 1000, chains = 4)
```

# Side‑by‑side summary

| Aspect | Plain R Euler | greta + greta.dynamics |
|----|----|----|
| Implementation | For‑loop updates numeric states | Graph builds symbolic states, evaluated via calculate() |
| Output | Numeric x, z directly | greta arrays -\> numerics via calculate() |
| Inference | Not built‑in | Add priors/likelihood -\> mcmc() for posteriors |
| Uncertainty | None | Full posterior uncertainty |
| Dependencies | Base R | TensorFlow backend via greta |

# Practical tips

-   Keep step size small (e.g., 0.01–0.1) to improve Euler accuracy.
-   If experimentation pushes states outside [0,1], reduce step size or
    consider a higher‑order solver.
-   When using calculate(), pass named arguments and extract by name to
    avoid ordering mistakes.
-   Ensure your tensorflow version is compatible with greta if you
    enable inference.

# Repro checklist

-   [ ] Baseline parameters defined (m, a, b, c, r, g, x_init, z_init)
-   [ ] RHS functions dx_dt, dz_dt
-   [ ] Choose DT and horizon t_max
-   [ ] Run Plain R simulation and plots
-   [ ] Run greta simulation and plots
-   [ ] (Optional) Add priors + likelihood and run mcmc()
