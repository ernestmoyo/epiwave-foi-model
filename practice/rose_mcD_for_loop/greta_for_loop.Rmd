---
title: "greta_for_loop"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

------------------------------------------------------------------------

title: "Ross–Macdonald in Plain R vs greta.dynamics" author: "Ernest
Moyo" date: "`r format(Sys.Date(), '%d %B %Y')`" output: html_document:
toc: true toc_depth: 3 number_sections: true df_print: paged
pdf_document: toc: true ---------

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 4)
```

# Overview

This R Markdown documents two ways to simulate the Ross–Macdonald
malaria model:

1.  Plain R forward‑Euler (deterministic, minimal dependencies).
2.  greta + greta.dynamics (same dynamics inside a probabilistic graph;
    can be extended to Bayesian inference).

We also note what greta adds (priors, likelihoods, MCMC) and include a
minimal Bayesian template.

# Model definition

Human infection proportion x(t) and mosquito infection proportion z(t):

-   dx/dt = m \* a \* b \* z \* (1 - x) - r \* x
-   dz/dt = a \* c \* x \* (1 - z) - g \* z

States: x(t), z(t) in [0,1]. Parameters (daily units): m, a, b, c, r =
1/infection_duration, g = 1/mosquito_lifespan.

Baseline numbers:

```{r params}
m <- 100; a <- 0.1; b <- 0.9; c <- 0.9
infection_duration <- 21; r <- 1/infection_duration
mosquito_lifespan  <- 21; g <- 1/mosquito_lifespan
x_init <- 0.02; z_init <- 0.001
```

Right‑hand sides (R functions):

```{r rhs}
dx_dt <- function(x, z, m, a, b, r) m * a * b * z * (1 - x) - r * x

dz_dt <- function(x, z, a, c, g)   a * c * x * (1 - z) - g * z
```

Instantaneous rates at the initial state (x0, z0):

```{r initial-slopes}
dx0 <- dx_dt(x_init, z_init, m, a, b, r)
dz0 <- dz_dt(x_init, z_init, a, c, g)
cat(sprintf("dx/dt at t0: %.6f per day
", dx0))
cat(sprintf("dz/dt at t0: %.6f per day
", dz0))
```

# Way 1 — Plain R Euler simulation

A forward‑Euler step with step size DT updates:

-   x[i+1] = x[i] + dx_dt(x[i], z[i], ...)\*DT
-   z[i+1] = z[i] + dz_dt(x[i], z[i], ...)\*DT

```{r plain-euler}
t_max <- 10
DT    <- 0.1
t     <- seq(0, t_max, by = DT)
n_t   <- length(t)

x <- z <- rep(NA_real_, n_t)
x[1] <- x_init; z[1] <- z_init

for (i in 2:n_t) {
  x[i] <- x[i - 1] + dx_dt(x[i - 1], z[i - 1], m, a, b, r) * DT
  z[i] <- z[i - 1] + dz_dt(x[i - 1], z[i - 1], a, c, g)   * DT
  # optional safety clamp if experimenting with large steps
  x[i] <- pmin(pmax(x[i], 0), 1)
  z[i] <- pmin(pmax(z[i], 0), 1)
}
```

```{r plot-plain, fig.height=4}
par(mfrow = c(1, 2))
plot(t, x, type = "l", xlab = "time (days)", ylab = "x (humans infected)", main = "Plain R: x(t)")
plot(t, z, type = "l", xlab = "time (days)", ylab = "z (mosq. infected)", main = "Plain R: z(t)")
par(mfrow = c(1, 1))
```

Notes:

-   Deterministic only; no uncertainty quantification.
-   Accuracy depends on DT. Use smaller steps if dynamics are fast.

# Way 2 — greta + greta.dynamics (deterministic run)

We build the same Euler simulation inside a greta computational graph.
Later, attach priors/likelihoods and run MCMC for Bayesian inference.

```{r greta-setup, message=TRUE}
# Install if needed (uncomment):
# install.packages("greta")
# remotes::install_github("greta-dev/greta.dynamics")

library(greta)
library(greta.dynamics)
```

Convert constants to greta data (greta arrays):

```{r greta-data}
m_g  <- as_data(m)
a_g  <- as_data(a)
b_g  <- as_data(b)
r_g  <- as_data(r)
c_g  <- as_data(c)
g_g  <- as_data(g)
DT_g <- as_data(0.1)

x0_g <- as_data(x_init)
z0_g <- as_data(z_init)

t_seq  <- seq(0, t_max, by = as.numeric(DT_g))
n_step <- length(t_seq) - 1
```

Define a greta‑compatible Euler transition:

```{r greta-transition}
step_greta <- function(state, m, a, b, c, r, g, DT, iter) {
  x <- state[1]; z <- state[2]
  x_next <- x + dx_dt(x, z, m, a, b, r) * DT
  z_next <- z + dz_dt(x, z, a, c, g)   * DT
  c(x_next, z_next)
}
```

Build the trajectory in the greta graph and evaluate to numerics:

```{r greta-run}
sol <- iterate_dynamic_function(
  transition_function = step_greta,
  initial_state = c(x0_g, z0_g),
  niter = n_step,
  tol = 0,          # purely deterministic
  m = m_g, a = a_g, b = b_g, c = c_g, r = r_g, g = g_g, DT = DT_g
)

x_ts_g <- sol$all_states[1, ]
z_ts_g <- sol$all_states[2, ]

vals <- calculate(x = x_ts_g, z = z_ts_g)
x_g_num <- as.numeric(vals$x)
z_g_num <- as.numeric(vals$z)
# time indices in greta output correspond to t_seq[-1] (after first step)
```

```{r plot-greta, fig.height=4}
par(mfrow = c(1, 2))
plot(t_seq[-1], x_g_num, type = "l", xlab = "time (days)", ylab = "x", main = "greta.dynamics: x(t)")
plot(t_seq[-1], z_g_num, type = "l", xlab = "time (days)", ylab = "z", main = "greta.dynamics: z(t)")
par(mfrow = c(1, 1))
```

What greta buys you:

-   Dynamics and parameters live in a probabilistic graph.
-   Add priors on parameters and a likelihood linking states to data;
    sample the posterior via mcmc().
-   Uncertainty‑aware estimates and predictions.

# Minimal Bayesian extension (template)

This is a sketch for when you have data; it won’t run until you define
observations y, sample sizes n, and the index mapping idx.

```{r bayes-template, eval=FALSE}
# Example priors (tune to your context)
m_g  <- lognormal(log(100), 0.3)
a_g  <- beta(2, 18)     # mean approx 0.1 on [0,1]
b_g  <- beta(9, 1)      # mean approx 0.9
c_g  <- beta(9, 1)
r_g  <- as_data(1/21)
g_g  <- as_data(1/21)
DT_g <- as_data(0.1)

# Build trajectory as before
sol <- iterate_dynamic_function(step_greta, c(x0_g, z0_g), n_step, tol = 0,
  m = m_g, a = a_g, b = b_g, c = c_g, r = r_g, g = g_g, DT = DT_g)

x_ts <- sol$all_states[1, ]  # greta array

# Suppose at selected times idx you observe y positives out of n tested
for (i in 1:n_obs) {
  y[i] ~ binomial(size = n[i], prob = x_ts[idx[i]])
}

# Build and sample the model
m <- model(y)
draws <- mcmc(m, n_samples = 2000, warmup = 1000, chains = 4)
```

# Side‑by‑side summary

| Aspect | Plain R Euler | greta + greta.dynamics |
|----|----|----|
| Implementation | For‑loop updates numeric states | Graph builds symbolic states, evaluated via calculate() |
| Output | Numeric x, z directly | greta arrays -\> numerics via calculate() |
| Inference | Not built‑in | Add priors/likelihood -\> mcmc() for posteriors |
| Uncertainty | None | Full posterior uncertainty |
| Dependencies | Base R | TensorFlow backend via greta |

# Practical tips

-   Keep step size small (e.g., 0.01–0.1) to improve Euler accuracy.
-   If experimentation pushes states outside [0,1], reduce step size or
    consider a higher‑order solver.
-   When using calculate(), pass named arguments and extract by name to
    avoid ordering mistakes.
-   Ensure your tensorflow version is compatible with greta if you
    enable inference.

# Repro checklist

-   [ ] Baseline parameters defined (m, a, b, c, r, g, x_init, z_init)
-   [ ] RHS functions dx_dt, dz_dt
-   [ ] Choose DT and horizon t_max
-   [ ] Run Plain R simulation and plots
-   [ ] Run greta simulation and plots
-   [ ] (Optional) Add priors + likelihood and run mcmc()

# Shifting to Multi-Site

This note explains, step by step, how the **multi-site** Ross–Macdonald
simulation works and *why* each part exists. Code chunks are
**runnable**. The multi-site design treats each location (“site”) as an
independent copy of the model, updated **in parallel** within a single
time loop.

## State Definitions

-   `x` — fraction of **humans infected** at a site (prevalence, 0–1).\
-   `z` — fraction of **mosquitoes infected** at a site (0–1).

## ODEs (Ross–Macdonald core)

$$
\begin{aligned}
\frac{dx}{dt} &= m\,a\,b\,z\,(1 - x) - r\,x, \\\\
\frac{dz}{dt} &= a\,c\,x\,(1 - z) - g\,z.
\end{aligned}
$$

-   $m$: mosquitoes per person (can vary by site/time).\
-   $a$: bites per mosquito per day.\
-   $b$: transmission mosquito → human.\
-   $c$: transmission human → mosquito.\
-   $r$: human recovery rate (≈ 1 / infectious period).\
-   $g$: mosquito mortality rate (≈ 1 / lifespan).

## Discretization (Euler step)

For time step $\Delta t$: $$
\text{state}_{t+\Delta t} = \text{state}_t + \frac{d(\text{state})}{dt}\,\Delta t.
$$

This is applied **element-wise** to each site.

------------------------------------------------------------------------

# Single-site functions

```{r}
dx_dt <- function(x, z, m, a, b, r) {
  m * a * b * z * (1 - x) - r * x
}

dz_dt <- function(x, z, a, c, g) {
  a * c * x * (1 - z) - g * z
}
```

# Parameters & initials (shared defaults)

```{r}
m <- 100
a <- 0.1
b <- 0.9
infection_duration <- 21
r <- 1 / infection_duration
c <- 0.9
mosquito_lifespan <- 21
g <- 1 / mosquito_lifespan

x_init <- 0.02
z_init <- 0.001
```

# Single-step sanity checks (optional)

```{r}
dx_dt(x = x_init, z = z_init, m = m, a = a, b = b, r = r)
dz_dt(x = x_init, z = z_init, a = a, c = c, g = g)

x_next_day <- x_init + dx_dt(x_init, z_init, m, a, b, r)
z_next_day <- z_init + dz_dt(x_init, z_init, a, c, g)

x_in_two_days  <- x_init + 2   * dx_dt(x_init, z_init, m, a, b, r)
x_in_0.1_days  <- x_init + 0.1 * dx_dt(x_init, z_init, m, a, b, r)

list(x_next_day = x_next_day,
     z_next_day = z_next_day,
     x_in_two_days = x_in_two_days,
     x_in_0.1_days = x_in_0.1_days)
```

------------------------------------------------------------------------

# Multi-site simulation (vectorised by site)

The multi-site block stacks sites by **rows** and time by **columns**.
We keep **one time loop** and do **vector arithmetic** across sites each
step.

## Why multiple sites?

-   Compare locations on the same time axis.
-   Share a clean implementation that is faster than looping over sites
    inside the time loop.
-   Allow site-varying drivers like $m(t)$ or site-specific parameters
    later.

## Time grid (shared by all sites)

```{r}
S <- 3            # number of sites (edit as needed)
t_max <- 10
dt <- 0.1
t <- seq(0, t_max, by = dt)
n_t <- length(t)
```

**Why:** one global clock makes sites comparable day-by-day.

## Initial conditions by site

```{r}
x0 <- rep(x_init, S)   # e.g., c(0.02, 0.015, 0.03)
z0 <- rep(z_init, S)
```

**Why:** each site needs its own starting values.

## Time-varying mosquito density per site: $m(t)$

```{r}
m0 <- c(8, 20, 50)     # start per site
mT <- c(100, 60, 80)   # end per site

# m_mat: S x n_t (rows = sites, cols = time)
m_mat <- sapply(t, function(tt) m0 + (mT - m0) * (tt / t_max))
dim(m_mat)  # sanity check
```

**Why:** capture seasonal or ecological changes differing by site.
Precomputing lets each step read $m$ instantly.

## State matrices

```{r}
x_mat <- matrix(NA_real_, nrow = S, ncol = n_t)
z_mat <- matrix(NA_real_, nrow = S, ncol = n_t)
x_mat[, 1] <- x0
z_mat[, 1] <- z0
```

**Why:** store the **entire** trajectory (rows = sites, cols = time).

## Single time loop; vector ops across sites

```{r}
for (j in 2:n_t) {
  x_prev <- x_mat[, j - 1]
  z_prev <- z_mat[, j - 1]
  m_now  <- m_mat[, j - 1]

  dx <- dx_dt(x = x_prev, z = z_prev, m = m_now, a = a, b = b, r = r)
  dz <- dz_dt(x = x_prev, z = z_prev,             a = a, c = c, g = g)

  # Optional: keep states in [0,1]
  x_mat[, j] <- pmin(pmax(x_prev + dx * dt, 0), 1)
  z_mat[, j] <- pmin(pmax(z_prev + dz * dt, 0), 1)
}
```

**Why each step:** 1. Grab previous states for all sites.\
2. Grab current $m$ for all sites.\
3. Compute derivatives with **vector inputs** (length `S`) →
element-wise arithmetic.\
4. Euler update for all sites simultaneously.

## Plots (one line per site)

```{r}
par(mfrow = c(1, 2))
matplot(t, t(x_mat), type = "l", lty = 1, xlab = "time", ylab = "x (humans infected)")
matplot(t, t(z_mat), type = "l", lty = 1, xlab = "time", ylab = "z (mosquitoes infected)")
```

------------------------------------------------------------------------

# Shared vs site-specific parameters (optional)

Right now `a, b, r, c, g` are **shared** across sites. Make them
**length-`S` vectors** to vary by site:

```{r}
# Example (commented by default)
# a_vec <- c(0.10, 0.08, 0.12)
# b_vec <- c(0.90, 0.85, 0.95)
# r_vec <- 1 / c(21, 18, 25)
# c_vec <- c(0.90, 0.88, 0.92)
# g_vec <- 1 / c(21, 25, 19)

# for (j in 2:n_t) {
#   x_prev <- x_mat[, j - 1]
#   z_prev <- z_mat[, j - 1]
#   m_now  <- m_mat[, j - 1]
#   dx <- m_now * a_vec * b_vec * z_prev * (1 - x_prev) - r_vec * x_prev
#   dz <- a_vec * c_vec * x_prev * (1 - z_prev) - g_vec * z_prev
#   x_mat[, j] <- pmin(pmax(x_prev + dx * dt, 0), 1)
#   z_mat[, j] <- pmin(pmax(z_prev + dz * dt, 0), 1)
# }
```

------------------------------------------------------------------------

# Guardrails & Tips

-   Keep `dt` small enough (e.g., 0.1 day) for stability with Euler.\
-   Clamp states to [0,1] (shown above).\
-   Validate dimensions early:

```{r}
stopifnot(identical(dim(m_mat), c(S, n_t)))
stopifnot(identical(dim(x_mat), c(S, n_t)))
stopifnot(identical(dim(z_mat), c(S, n_t)))
```

------------------------------------------------------------------------

# Next steps

-   Introduce **coupling** between sites with a movement/mixing matrix
    $W$.\
-   Swap Euler for a higher-order ODE solver (e.g., `deSolve::ode`).\
-   Fit parameters to data via Bayesian methods (e.g., `greta`) or
    likelihood-based approaches.
